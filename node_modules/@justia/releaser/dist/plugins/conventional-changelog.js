"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const conventional_changelog_1 = __importDefault(require("@release-it/conventional-changelog"));
const log_1 = __importDefault(require("../log"));
const calver_1 = __importDefault(require("./calver"));
class ConventionalChangelog extends conventional_changelog_1.default {
    /**
     * Proxy method to validate if the changelog is empty.
     */
    generateChangelog(options) {
        return super.generateChangelog(options).then((value) => {
            if (value.match(/^## \[[0-9.]+\]\([^)]+\)\s\([0-9-]+\)$/gs)) {
                log_1.default.info('No changes to be listed in the changelog');
                process.exit();
            }
            return value;
        });
    }
    async getIncrementedVersion({ increment, latestVersion, isPreRelease, preReleaseId }) {
        const { plugins = {} } = this.config.options;
        const calverPlugin = Object.keys(plugins).find((plugin) => plugin.includes('/calver.js'));
        if (!calverPlugin) {
            return Promise.resolve(super.getIncrementedVersion({ increment, latestVersion, isPreRelease, preReleaseId }));
        }
        const namespace = 'calver';
        const options = calverPlugin in plugins ? { [namespace]: plugins[calverPlugin] } : {};
        // eslint-disable-next-line @typescript-eslint/unbound-method
        const { config, log, shell, spinner, prompt, debug } = this;
        const container = { config, log, shell, spinner, prompt, debug };
        return new calver_1.default({ namespace, options, container }).getIncrementedVersion({
            latestVersion
        });
    }
}
module.exports = ConventionalChangelog;
