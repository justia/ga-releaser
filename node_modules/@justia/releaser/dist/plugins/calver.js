"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const release_it_1 = require("release-it");
const conventional_recommended_bump_1 = __importDefault(require("conventional-recommended-bump"));
const calver_1 = __importDefault(require("calver"));
const index_1 = __importDefault(require("../index"));
const log_1 = __importDefault(require("../log"));
const { justia: { calverFormat } } = index_1.default;
class CalverPlugin extends release_it_1.Plugin {
    /**
     * Get calendar versioning format
     */
    getFormat() {
        const { format } = this.getContext();
        return format || calverFormat;
    }
    /**
     * Get latest tag from context
     */
    getLatestTag() {
        return this.getContext('latestTag') || this.config.getContext('latestTag');
    }
    getLatestVersion() {
        const latestTagName = this.getLatestTag();
        const { fallbackVersion } = this.config.options.justia;
        return latestTagName ? latestTagName.replace(/^v/, '') : fallbackVersion;
    }
    async getIncrementedVersion({ latestVersion }) {
        let version;
        const format = this.getFormat();
        if (!latestVersion) {
            return calver_1.default.init(format);
        }
        try {
            return calver_1.default.inc(format, latestVersion, 'calendar');
        }
        catch (e) {
            // The new calver version throws if the calendar update doesn't have changes of current version.
            // but that doesn't really an exception. That's the reason to use 2 try blocks separated.
            version = latestVersion;
        }
        try {
            return calver_1.default.inc(format, version, await this.getIncrementType());
        }
        catch (e) {
            return await this.getIncrementedVersion({ latestVersion: '' });
        }
    }
    getIncrementType() {
        const conventionalChangelogConfig = this.config.getContext('conventional-changelog');
        return new Promise((resolve, reject) => conventional_recommended_bump_1.default({ ...conventionalChangelogConfig, ...this.options }, 
        // eslint-disable-next-line consistent-return
        (err, result) => {
            this.debug({ err, result });
            if (err)
                return reject(err);
            // Small convertion, conventionalRecommendedBump uses 'patch' instead 'micro'
            let releaseType = result.releaseType === 'patch' || !result.releaseType ? 'micro' : result.releaseType;
            const parts = this.getFormat()
                .split('.')
                .map((part) => part.toLowerCase());
            const availableVersions = ['major', 'minor', 'micro'];
            if (!parts.includes(releaseType)) {
                releaseType = parts.find((type) => availableVersions.includes(type));
            }
            resolve(releaseType);
        }));
    }
    getIncrementedVersionCI({ latestVersion }) {
        return this.getIncrementedVersion({ latestVersion });
    }
    getIncrement({ latestVersion }) {
        return this.getIncrementedVersion({ latestVersion });
    }
    beforeBump() {
        // hotfix: issue with release-it with calver
        // Reference: https://github.com/release-it/release-it/blob/2c66707fcabd2ac360860e14fa607153524f261e/lib/tasks.js#L85
        const versionObj = this.config.getContext('version');
        if (typeof versionObj === 'object' && versionObj.constructor.name === 'SemVer') {
            const parts = this.getFormat().split('.').length;
            const version = versionObj.version.split('.').slice(0, parts).join('.');
            log_1.default.info(`Fixing version...\nCurrent version: ${versionObj.version}\nNew version: ${version}`);
            this.config.setContext({ version: { version } });
        }
    }
}
module.exports = CalverPlugin;
