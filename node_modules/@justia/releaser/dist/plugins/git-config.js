"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const release_it_1 = require("release-it");
const log_1 = __importDefault(require("../log"));
class GitConfigPlugin extends release_it_1.Plugin {
    constructor() {
        super(...arguments);
        this.useVersionBranch = false;
        this.removeVersionBranch = false;
        this.branch = '';
    }
    async init() {
        const { name, email, removeVersionBranch } = this.options;
        const { useVersionBranch } = this.config.options.justia;
        this.useVersionBranch = useVersionBranch;
        this.removeVersionBranch = removeVersionBranch;
        this.registerPrompts();
        await this.step({
            enabled: true,
            task: () => this.fetchAll(),
            label: 'Git pre-fetching remote tags',
            prompt: 'fetch_remote'
        });
        if (name || email) {
            await this.step({
                enabled: true,
                task: () => Promise.all([this.configName(name), this.configEmail(email)]),
                label: 'Git pre-config (fetch, set name and email)',
                prompt: 'pre_config'
            });
        }
    }
    /**
     * Register prompts to CLI version
     */
    registerPrompts() {
        super.registerPrompts({
            fetch_remote: {
                type: 'confirm',
                message: () => 'Do you want to pre fetch remote git tags?',
                default: true
            },
            pre_config: {
                type: 'confirm',
                message: () => 'Do you want to pre configure GIT? (user, email)',
                default: true
            },
            checkout: {
                type: 'confirm',
                message: () => 'Do you want to checkout to a versioned branch?',
                default: true
            },
            push_versioned: {
                type: 'confirm',
                message: () => 'Do you want to push the versioned branch?',
                default: true
            },
            remove: {
                type: 'confirm',
                message: () => 'Do you want to remove the versioned branch?',
                default: true
            }
        });
    }
    /**
     * Get latest tag from context
     */
    getLatestTag() {
        return this.getContext('latestTag') || this.config.getContext('latestTag');
    }
    getLatestVersion() {
        const latestTagName = this.getLatestTag();
        const { fallbackVersion } = this.config.options.justia;
        return latestTagName ? latestTagName.replace(/^v/, '') : fallbackVersion;
    }
    async beforeBump() {
        if (!this.useVersionBranch) {
            return;
        }
        const version = this.config.getContext('version');
        this.branch = `v${version}`;
        log_1.default.info(`Handling version ${this.branch}`);
        await this.step({
            enabled: true,
            task: () => this.checkoutBranch(this.branch),
            label: 'Git checkout',
            prompt: 'checkout'
        });
    }
    async beforeRelease() {
        if (!this.useVersionBranch) {
            return;
        }
        await this.step({
            enabled: true,
            task: () => this.pushNewBranch(this.branch),
            label: 'Git push new branch',
            prompt: 'push_versioned'
        });
    }
    async afterRelease() {
        if (!this.useVersionBranch || !this.removeVersionBranch) {
            return;
        }
        await this.step({
            enabled: true,
            task: () => this.removeBranch(this.branch),
            label: 'Git remove versioned branch',
            prompt: 'remove'
        });
    }
    /**
     * Fetch all tags from origin
     */
    async fetchAll() {
        return this.exec(['git', 'fetch', '--prune', '--tags']).catch((err) => {
            this.log.error(`Could not fetch the repository`);
            this.debug(err);
        });
    }
    /**
     * Config name into GIT
     */
    async configName(name) {
        if (!name) {
            return Promise.resolve();
        }
        return this.exec(['git', 'config', 'user.name', name]).catch((err) => {
            this.log.error(`Could not config the git name ${name}`);
            this.debug(err);
        });
    }
    /**
     * Config email into GIT
     */
    async configEmail(email) {
        if (!email) {
            return Promise.resolve();
        }
        return this.exec(['git', 'config', 'user.email', email]).catch((err) => {
            this.log.error(`Could not config the git email ${email}`);
            this.debug(err);
        });
    }
    /**
     * Checkout branch
     */
    async checkoutBranch(branch) {
        return this.exec(['git', 'checkout', '-B', branch]).catch((err) => {
            this.log.error(`Could not checkout to branch ${branch}`);
            this.debug(err);
        });
    }
    /**
     * Push branch to origin
     */
    async pushNewBranch(branch) {
        return this.exec(['git', 'push', '-u', 'origin', branch]).catch((err) => {
            this.log.error(`Could not push branch ${branch} to origin`);
            this.debug(err);
        });
    }
    /**
     * Remove branch
     */
    async removeBranch(branch) {
        const { baseBranch } = this.config.options.justia;
        return this.exec(['git', 'push', 'origin', '--delete', branch])
            .then(() => this.checkoutBranch(baseBranch))
            .then(() => this.exec(['git', 'branch', '--delete', branch]))
            .catch((err) => {
            this.log.error(`Could not remove the branch ${branch} from origin`);
            this.debug(err);
        });
    }
}
module.exports = GitConfigPlugin;
